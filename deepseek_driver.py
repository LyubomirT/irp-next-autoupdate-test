import os
import time
import json
import asyncio
import httpx
from patchright.async_api import async_playwright, Page, Browser, BrowserContext
from dotenv import load_dotenv

load_dotenv()

class DeepSeekDriver:
    def __init__(self):
        self.playwright = None
        self.browser: Browser = None
        self.context: BrowserContext = None
        self.page: Page = None
        self.is_running = False

    async def start(self):
        """
        Starts the browser and navigates to DeepSeek.
        """
        print("Starting DeepSeek Driver...")
        self.playwright = await async_playwright().start()
        # Launch Chromium
        # headless=False to see the browser
        print("Launching Chromium...")
        self.browser = await self.playwright.chromium.launch(headless=False)
        
        # Create a new context
        self.context = await self.browser.new_context()
        
        # Create a new page
        self.page = await self.context.new_page()
        
        print("Navigating to https://chat.deepseek.com/ ...")
        await self.page.goto("https://chat.deepseek.com/")
        
        # Handle Login
        await self.login()
        
        self.is_running = True
        print("DeepSeek Driver started successfully.")

    async def login(self):
        """
        Handles the login process if redirected to the sign-in page.
        """
        # Check if we were redirected to sign in
        if "sign_in" in self.page.url:
            print("Redirected to sign in page. Attempting to log in...")
            
            email = os.getenv("DEEPSEEK_EMAIL")
            password = os.getenv("DEEPSEEK_PASSWORD")
            
            if not email or not password:
                print("Error: DEEPSEEK_EMAIL or DEEPSEEK_PASSWORD not found in environment variables.")
                return
            else:
                try:
                    # Wait for the form to appear
                    await self.page.wait_for_selector(".ds-sign-up-form__main")
                    
                    # Fill email
                    print(f"Entering email: {email}")
                    await self.page.fill("input[type='text']", email)
                    
                    # Fill password
                    print("Entering password...")
                    await self.page.fill("input[type='password']", password)
                    
                    # Click login button
                    print("Clicking login button...")
                    await self.page.click(".ds-sign-up-form__register-button")
                    
                    # Wait for navigation back to the chat page
                    await self.page.wait_for_url("https://chat.deepseek.com/")
                    print("Login successful.")
                    
                except Exception as e:
                    print(f"Error during auto-login: {e}")
        else:
            print("Not redirected to sign in. Continuing...")

    async def close(self):
        """
        Closes the browser and playwright.
        """
        print("Closing DeepSeek Driver...")
        if self.context:
            await self.context.close()
        if self.browser:
            await self.browser.close()
        if self.playwright:
            await self.playwright.stop()
        self.is_running = False
        print("DeepSeek Driver closed.")

    async def generate_response(self, message: str, model: str = "deepseek-chat", stream: bool = False, temperature: float = None, top_p: float = None):
        """
        Generates a response from DeepSeek.
        This function intercepts the network request to support streaming.
        """
        response_queue = asyncio.Queue()
        
        async def handle_route(route):
            request = route.request
            print(f"Intercepted request to: {request.url}")
            
            # Prepare headers and cookies
            headers = await request.all_headers()
            # Remove headers auto-generated by httpx
            headers.pop("content-length", None)
            headers.pop("host", None)
            
            # Get cookies from the context
            cookies = await self.context.cookies()
            cookie_dict = {c['name']: c['value'] for c in cookies}
            
            # Get the original post data
            post_data = request.post_data_json
            
            # Don't touch the original post data, as the ui needs what it sent
            # But we could modify it here if needed
            full_response_body = b""
            response_headers = {}
            
            async with httpx.AsyncClient() as client:
                try:
                    async with client.stream("POST", request.url, headers=headers, cookies=cookie_dict, json=post_data, timeout=60.0) as response:
                        # Capture headers to forward them later
                        # We specifically need Content-Type so the frontend knows it's an SSE stream
                        for k, v in response.headers.items():
                            response_headers[k] = v
                            
                        async for chunk in response.aiter_bytes():
                            full_response_body += chunk
                            # Process chunk for streaming
                            await self._process_chunk(chunk, response_queue)
                            
                except Exception as e:
                    print(f"Error during intercepted request: {e}")
                    await response_queue.put({"error": str(e)})
            
            # Fulfill the original request so the UI updates
            try:
                # Forward the captured headers, especially Content-Type
                await route.fulfill(body=full_response_body, status=200, headers=response_headers)
            except Exception as e:
                print(f"Error fulfilling route: {e}")
            
            # Signal end of stream
            await response_queue.put(None)

        # Set up interception
        await self.page.route("**/api/v0/chat/completion", handle_route)
        
        try:
            # Trigger UI interaction
            # Clear previous chat by clicking New Chat
            await self._click_new_chat()
            # Small wait for the UI to update
            await asyncio.sleep(0.5)
            
            await self._enter_message(message)
            await self._send_message()
            
            # Yield responses from queue
            while True:
                item = await response_queue.get()
                if item is None:
                    break
                if isinstance(item, dict) and "error" in item:
                    yield f"data: {json.dumps(item)}\n\n"
                    break
                
                yield item
                
        finally:
            # Cleanup interception
            await self.page.unroute("**/api/v0/chat/completion")

    async def _process_chunk(self, chunk: bytes, queue: asyncio.Queue):
        """
        Parses raw bytes from DeepSeek and puts OpenAI-formatted chunks into the queue.
        """
        try:
            text = chunk.decode("utf-8")
            lines = text.split("\n")
            for line in lines:
                if line.startswith("data: "):
                    data_str = line[6:]
                    if data_str.strip() == "[DONE]": # Should not happen with DeepSeek but good practice after I implement other LMs
                        continue
                    
                    try:
                        data = json.loads(data_str)
                        # Transform DeepSeek data to OpenAI format
                        # DeepSeek format based on my findings:
                        # data: {"v": " content"}
                        # data: {"v": [{"v": "FINISHED", "p": "status"}, ...]}
                        # The one below is special for fragments (that's where the first token is)
                        # data: {"v": [{"v": [{"id": 1, "type": "RESPONSE", "content": "Hello", ...}], "p": "fragments", "o": "APPEND"}], "p": "response", "o": "BATCH"}
                        
                        content = ""
                        finish_reason = None
                        
                        if "v" in data:
                            v = data["v"]
                            if isinstance(v, str):
                                content = v
                            elif isinstance(v, list):
                                # Check for status or BATCH updates
                                for item in v:
                                    if isinstance(item, dict):
                                        # Check for status update
                                        if item.get("p") == "status" and item.get("v") == "FINISHED":
                                            finish_reason = "stop"
                                        
                                        # Check for fragments append (first token here)
                                        if item.get("p") == "fragments" and item.get("o") == "APPEND":
                                            fragments = item.get("v")
                                            if isinstance(fragments, list):
                                                for frag in fragments:
                                                    if isinstance(frag, dict) and "content" in frag:
                                                        content += frag["content"]
                        
                        if content or finish_reason:
                            openai_chunk = {
                                "id": "chatcmpl-custom",
                                "object": "chat.completion.chunk",
                                "created": int(time.time()),
                                "model": "deepseek-chat",
                                "choices": [
                                    {
                                        "index": 0,
                                        "delta": {"content": content} if content else {},
                                        "finish_reason": finish_reason
                                    }
                                ]
                            }
                            await queue.put(f"data: {json.dumps(openai_chunk)}\n\n")
                            
                    except json.JSONDecodeError:
                        pass
        except Exception as e:
            print(f"Error processing chunk: {e}")

    async def set_deepthink_state(self, state: bool):
        """
        Toggles the DeepThink mode to the desired state.
        """
        button = self.page.locator("button.ds-toggle-button", has_text="DeepThink")
        
        if await button.count() == 0:
            print("DeepThink button not found.")
            return

        class_attr = await button.first.get_attribute("class") or ""
        is_selected = "ds-toggle-button--selected" in class_attr
        
        if is_selected != state:
            print(f"Toggling DeepThink to {state}...")
            await button.first.click()
        else:
            print(f"DeepThink is already {state}.")

    async def set_search_state(self, state: bool):
        """
        Toggles the Search mode to the desired state.
        """
        button = self.page.locator("button.ds-toggle-button", has_text="Search")
        
        if await button.count() == 0:
            print("Search button not found.")
            return

        class_attr = await button.first.get_attribute("class") or ""
        is_selected = "ds-toggle-button--selected" in class_attr
        
        if is_selected != state:
            print(f"Toggling Search to {state}...")
            await button.first.click()
        else:
            print(f"Search is already {state}.")

    async def set_sidebar_status(self, open: bool):
        """
        Sets the sidebar status to open or closed.
        """
        sidebar_inner_selector = "div.b8812f16.a2f3d50e"
        sidebar_closed_class = "_70b689f"
        close_button_selector = "div.ds-icon-button._7d1f5e2"
        open_button_selector = "div.e5bf614e >> div.ds-icon-button._4f3769f >> nth=0"

        sidebar_inner = self.page.locator(sidebar_inner_selector)
        if await sidebar_inner.count() == 0:
            print("Sidebar inner container not found.")
            return

        class_attr = await sidebar_inner.first.get_attribute("class") or ""
        is_closed = sidebar_closed_class in class_attr
        is_open = not is_closed

        if open:
            if is_open:
                print("Sidebar is already open.")
                return

            print("Opening sidebar...")
            open_btn = self.page.locator(open_button_selector)
            if await open_btn.is_visible():
                await open_btn.click()
            else:
                print("Open sidebar button not visible.")
                
        else:
            if is_closed:
                print("Sidebar is already closed.")
                return
            
            print("Closing sidebar...")
            close_btn = self.page.locator(close_button_selector)
            if await close_btn.is_visible():
                await close_btn.click()
            else:
                print("Close sidebar button not visible.")

    async def click_new_chat(self, source: str = "auto"):
        """
        Clicks the New Chat button.
        """
        simple_new_chat_selector = "div.e5bf614e >> div.ds-icon-button._4f3769f >> nth=1"
        sidebar_new_chat_selector = "div._5a8ac7a.a084f19e"

        if source == "simple":
            print("Clicking New Chat (Simple)...")
            btn = self.page.locator(simple_new_chat_selector)
            if await btn.count() > 0:
                await btn.click()
            else:
                print("New Chat (Simple) button not found.")
                
        elif source == "sidebar":
            print("Clicking New Chat (Sidebar)...")
            btn = self.page.locator(sidebar_new_chat_selector)
            if await btn.count() > 0:
                await btn.click()
            else:
                print("New Chat (Sidebar) button not found.")
                
        elif source == "auto":
            print("Attempting to click New Chat (Auto)...")
            simple_btn = self.page.locator(simple_new_chat_selector)
            if await simple_btn.count() > 0:
                print("Found Simple New Chat button. Clicking...")
                await simple_btn.click()
                return
                
            sidebar_btn = self.page.locator(sidebar_new_chat_selector)
            if await sidebar_btn.count() > 0:
                print("Found Sidebar New Chat button. Clicking...")
                await sidebar_btn.click()
                return
                
            print("Could not find New Chat button in either mode.")
        else:
            print(f"Unknown source: {source}")

    async def enter_message(self, message: str):
        """
        Public wrapper for entering a message.
        """
        await self._enter_message(message)

    async def send_message(self):
        """
        Public wrapper for sending a message.
        """
        await self._send_message()

    async def _enter_message(self, message: str):
        """
        Enters the message into the chat input textarea.
        """
        # The textarea has placeholder "Message DeepSeek"
        textarea = self.page.locator("textarea[placeholder='Message DeepSeek']")
        if await textarea.count() == 0:
            print("Message textarea not found.")
            return
        print(f"Entering message: {message}")
        await textarea.fill(message)

    async def _send_message(self):
        """
        Clicks the send button if it is enabled.
        """
        # The send button is a div with role="button" and class "ds-icon-button"
        # The send button has a specific hashed class "_7436101"
        send_button = self.page.locator("div.ds-icon-button._7436101")
        
        if await send_button.count() > 0:
            is_disabled = await send_button.get_attribute("aria-disabled") == "true"
            if not is_disabled:
                print("Clicking send button...")
                await send_button.click()
            else:
                print("Send button is disabled. Cannot send message.")
        else:
            print("Send button could not be located.")

    async def _click_new_chat(self):
        """
        Clicks the New Chat button.
        """
        await self.click_new_chat(source="auto")

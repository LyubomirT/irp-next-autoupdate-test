import os
import time
import json
import asyncio
import httpx
from patchright.async_api import async_playwright, Page, Browser, BrowserContext
from dotenv import load_dotenv

load_dotenv()

class DeepSeekDriver:
    def __init__(self):
        self.playwright = None
        self.browser: Browser = None
        self.context: BrowserContext = None
        self.page: Page = None
        self.is_running = False
        
        # Settings
        self.enable_deepthink = False
        self.enable_search = False
        self.send_deepthink = False

    async def start(self):
        """
        Starts the browser and navigates to DeepSeek.
        """
        print("Starting DeepSeek Driver...")
        self.playwright = await async_playwright().start()
        # Launch Chromium
        # headless=False to see the browser
        print("Launching Chromium...")
        self.browser = await self.playwright.chromium.launch(headless=False)
        
        # Create a new context
        self.context = await self.browser.new_context()
        
        # Create a new page
        self.page = await self.context.new_page()
        
        print("Navigating to https://chat.deepseek.com/ ...")
        await self.page.goto("https://chat.deepseek.com/")
        
        # Handle Login
        await self.login()
        
        self.is_running = True
        print("DeepSeek Driver started successfully.")

    async def login(self):
        """
        Handles the login process if redirected to the sign-in page.
        """
        # Check if we were redirected to sign in
        if "sign_in" in self.page.url:
            print("Redirected to sign in page. Attempting to log in...")
            
            email = os.getenv("DEEPSEEK_EMAIL")
            password = os.getenv("DEEPSEEK_PASSWORD")
            
            if not email or not password:
                print("Error: DEEPSEEK_EMAIL or DEEPSEEK_PASSWORD not found in environment variables.")
                return
            else:
                try:
                    # Wait for the form to appear
                    await self.page.wait_for_selector(".ds-sign-up-form__main")
                    
                    # Fill email
                    print(f"Entering email: {email}")
                    await self.page.fill("input[type='text']", email)
                    
                    # Fill password
                    print("Entering password...")
                    await self.page.fill("input[type='password']", password)
                    
                    # Click login button
                    print("Clicking login button...")
                    await self.page.click(".ds-sign-up-form__register-button")
                    
                    # Wait for navigation back to the chat page
                    await self.page.wait_for_url("https://chat.deepseek.com/")
                    print("Login successful.")
                    
                except Exception as e:
                    print(f"Error during auto-login: {e}")
        else:
            print("Not redirected to sign in. Continuing...")

    async def close(self):
        """
        Closes the browser and playwright.
        """
        print("Closing DeepSeek Driver...")
        if self.context:
            await self.context.close()
        if self.browser:
            await self.browser.close()
        if self.playwright:
            await self.playwright.stop()
        self.is_running = False
        print("DeepSeek Driver closed.")

    async def generate_response(self, message: str, model: str = "deepseek-chat", stream: bool = False, temperature: float = None, top_p: float = None):
        """
        Generates a response from DeepSeek.
        This function intercepts the network request to support streaming.
        """
        response_queue = asyncio.Queue()
        
        # Reset state for new generation
        self.fragment_types_list = []
        self.thinking_active = False
        
        async def handle_route(route):
            request = route.request
            print(f"Intercepted request to: {request.url}")
            
            # Prepare headers and cookies
            headers = await request.all_headers()
            # Remove headers auto-generated by httpx
            headers.pop("content-length", None)
            headers.pop("host", None)
            
            # Get cookies from the context
            cookies = await self.context.cookies()
            cookie_dict = {c['name']: c['value'] for c in cookies}
            
            # Get the original post data
            post_data = request.post_data_json
            
            # Don't touch the original post data, as the ui needs what it sent
            # But we could modify it here if needed
            full_response_body = b""
            response_headers = {}
            
            async with httpx.AsyncClient() as client:
                try:
                    async with client.stream("POST", request.url, headers=headers, cookies=cookie_dict, json=post_data, timeout=60.0) as response:
                        # Capture headers to forward them later
                        # We specifically need Content-Type so the frontend knows it's an SSE stream
                        for k, v in response.headers.items():
                            response_headers[k] = v
                            
                        async for chunk in response.aiter_bytes():
                            full_response_body += chunk
                            # Process chunk for streaming
                            await self._process_chunk(chunk, response_queue)
                            
                except Exception as e:
                    print(f"Error during intercepted request: {e}")
                    await response_queue.put({"error": str(e)})
            
            # Fulfill the original request so the UI updates
            try:
                # Forward the captured headers, especially Content-Type
                await route.fulfill(body=full_response_body, status=200, headers=response_headers)
            except Exception as e:
                print(f"Error fulfilling route: {e}")
            
            # Signal end of stream
            await response_queue.put(None)

        # Set up interception
        await self.page.route("**/api/v0/chat/completion", handle_route)
        
        try:
            # Trigger UI interaction
            # Clear previous chat by clicking New Chat
            await self._click_new_chat()
            # Small wait for the UI to update
            await asyncio.sleep(0.5)
            
            await self._enter_message(message)
            
            # Apply settings before sending
            await self.set_deepthink_state(self.enable_deepthink)
            await self.set_search_state(self.enable_search)
            
            await self._send_message()
            
            # Yield responses from queue
            while True:
                item = await response_queue.get()
                if item is None:
                    break
                if isinstance(item, dict) and "error" in item:
                    yield f"data: {json.dumps(item)}\n\n"
                    break
                
                yield item
                
        finally:
            # Cleanup interception
            await self.page.unroute("**/api/v0/chat/completion")

    async def _process_chunk(self, chunk: bytes, queue: asyncio.Queue):
        """
        Parses raw bytes from DeepSeek and puts OpenAI-formatted chunks into the queue.
        """
        try:
            text = chunk.decode("utf-8")
            lines = text.split("\n")
            for line in lines:
                if line.startswith("data: "):
                    data_str = line[6:]
                    if data_str.strip() == "[DONE]": 
                        continue
                    
                    try:
                        data = json.loads(data_str)
                        # Transform DeepSeek data to OpenAI format
                        # DeepSeek format based on my findings:
                        # data: {"v": " content"}
                        # data: {"v": [{"v": "FINISHED", "p": "status"}, ...]}
                        # The one below is special for fragments (that's where the first token is)
                        # data: {"v": [{"v": [{"id": 1, "type": "RESPONSE", "content": "Hello", ...}], "p": "fragments", "o": "APPEND"}], "p": "response", "o": "BATCH"}
                        
                        content = ""
                        finish_reason = None
                        
                        if "v" in data:
                            v = data["v"]
                            if isinstance(v, str):
                                content = v
                            elif isinstance(v, list):
                                # Check for status or BATCH updates
                                for item in v:
                                    if isinstance(item, dict):
                                        # Check for status update
                                        if item.get("p") == "status" and item.get("v") == "FINISHED":
                                            finish_reason = "stop"
                                        
                                        # Check for fragments append (first token here)
                                        # data: {"v": [{"v": [{"id": 1, "type": "THINK", ...}], "p": "fragments", "o": "APPEND"}], ...}
                                        if item.get("p") == "fragments" and item.get("o") == "APPEND":
                                            fragments = item.get("v")
                                            if isinstance(fragments, list):
                                                for frag in fragments:
                                                    if isinstance(frag, dict):
                                                        frag_type = frag.get("type")
                                                        frag_id = frag.get("id")
                                                        
                                                        # Store fragment type
                                                        if not hasattr(self, "fragment_types"):
                                                            self.fragment_types = {}
                                                        self.fragment_types[frag_id] = frag_type
                                                        
                                                        # Handle THINK start
                                                        if frag_type == "THINK" and self.send_deepthink:
                                                            content += "<think>"
                                                            self.thinking_active = True
                                                        
                                                        # Handle RESPONSE start (end of THINK if active)
                                                        if frag_type == "RESPONSE" and getattr(self, "thinking_active", False):
                                                            content += "</think>"
                                                            self.thinking_active = False
                                                        
                                                        if "content" in frag:
                                                            # Only append content if allowed
                                                            if frag_type == "THINK":
                                                                if self.send_deepthink:
                                                                    content += frag["content"]
                                                            elif frag_type == "SEARCH":
                                                                pass # Ignore search content for now
                                                            else:
                                                                content += frag["content"]

                            # Handle path-based updates
                            # data: {"v": " content", "p": "response/fragments/0/content", "o": "APPEND"}
                            elif isinstance(v, dict) and "p" in data:
                                path = data.get("p")
                                value = data.get("v")
                                op = data.get("o")
                                
                                # Check if it's a fragment content update
                                if path and path.startswith("response/fragments/"):
                                    parts = path.split("/")
                                    if len(parts) >= 4 and parts[3] == "content":
                                        try:
                                            frag_index = int(parts[2])
                                            # fragments: [{"id": 1, "type": "THINK"}] -> index 0
                                            # fragments: [{"id": 2, "type": "RESPONSE"}] -> index 1
                                            # So index 0 maps to ID 1.
                                            
                                            # Maintain a list of types in order of appearance
                                            if not hasattr(self, "fragment_type_list"):
                                                self.fragment_type_list = []
                                            
                                            # If we missed the creation (shouldn't happen if sequential), we have a problem.
                                            pass
                                        except ValueError:
                                            pass
                        
                        # Let's refine the logic inside the loop
                        pass

                    except json.JSONDecodeError:
                        pass
        except Exception as e:
            print(f"Error processing chunk: {e}")
            
    # Redefining _process_chunk completely to be cleaner and use instance state initialized in generate_response
    async def _process_chunk(self, chunk: bytes, queue: asyncio.Queue):
        try:
            text = chunk.decode("utf-8")
            lines = text.split("\n")
            for line in lines:
                if line.startswith("data: "):
                    data_str = line[6:]
                    if data_str.strip() == "[DONE]": 
                        continue
                    
                    try:
                        data = json.loads(data_str)
                        content = ""
                        finish_reason = None
                        
                        # Handle "v" value directly (simple updates) or complex objects
                        if "v" in data:
                            v = data["v"]
                            p = data.get("p")
                            o = data.get("o")
                            
                            # Case 1: Batch update or simple value without path
                            # or BATCH update for response
                            if p is None or (p == "response" and o == "BATCH"):
                                if isinstance(v, str):
                                    content = v
                                elif isinstance(v, list):
                                    # Iterate through batch items
                                    for item in v:
                                        if isinstance(item, dict):
                                            # Status update
                                            if item.get("p") == "status" and item.get("v") == "FINISHED":
                                                finish_reason = "stop"
                                                # Close think tag if open
                                                if getattr(self, "thinking_active", False):
                                                    content += "</think>"
                                                    self.thinking_active = False
                                            
                                            # Fragments append (New Fragment)
                                            if item.get("p") == "fragments" and item.get("o") == "APPEND":
                                                fragments = item.get("v")
                                                if isinstance(fragments, list):
                                                    for frag in fragments:
                                                        if isinstance(frag, dict):
                                                            frag_type = frag.get("type")
                                                            # Store type by index (len of list before append)
                                                            if not hasattr(self, "fragment_types_list"):
                                                                self.fragment_types_list = []
                                                            self.fragment_types_list.append(frag_type)
                                                            
                                                            # Handle THINK start
                                                            if frag_type == "THINK" and self.send_deepthink:
                                                                content += "<think>"
                                                                self.thinking_active = True
                                                            
                                                            # Handle RESPONSE start (end of THINK if active)
                                                            if frag_type == "RESPONSE" and getattr(self, "thinking_active", False):
                                                                content += "</think>"
                                                                self.thinking_active = False
                                                            
                                                            # Initial content
                                                            if "content" in frag:
                                                                if frag_type == "THINK":
                                                                    if self.send_deepthink:
                                                                        content += frag["content"]
                                                                elif frag_type == "SEARCH":
                                                                    pass
                                                                else:
                                                                    content += frag["content"]
                                                                    
                                            # Response status update (in batch)
                                            if item.get("p") == "response" and isinstance(item.get("v"), dict):
                                                # Check inside response object if needed
                                                pass

                            # Case 2: Path-based update
                            else:
                                # Check for new fragment append: response/fragments
                                if p == "response/fragments" and o == "APPEND":
                                    fragments = v
                                    if isinstance(fragments, list):
                                        for frag in fragments:
                                            if isinstance(frag, dict):
                                                frag_type = frag.get("type")
                                                frag_id = frag.get("id")
                                                
                                                # Store fragment type
                                                if not hasattr(self, "fragment_types"):
                                                    self.fragment_types = {}
                                                self.fragment_types[frag_id] = frag_type
                                                
                                                # Store type by index (len of list before append)
                                                if not hasattr(self, "fragment_types_list"):
                                                    self.fragment_types_list = []
                                                self.fragment_types_list.append(frag_type)
                                                
                                                # Handle THINK start
                                                if frag_type == "THINK" and self.send_deepthink:
                                                    content += "<think>"
                                                    self.thinking_active = True
                                                
                                                # Handle RESPONSE start (end of THINK if active)
                                                if frag_type == "RESPONSE" and getattr(self, "thinking_active", False):
                                                    content += "</think>"
                                                    self.thinking_active = False
                                                
                                                # Initial content
                                                if "content" in frag:
                                                    if frag_type == "THINK":
                                                        if self.send_deepthink:
                                                            content += frag["content"]
                                                    elif frag_type == "SEARCH":
                                                        pass
                                                    else:
                                                        content += frag["content"]

                                # Check for content update: response/fragments/0/content
                                elif p.startswith("response/fragments/") and p.endswith("/content"):
                                    try:
                                        parts = p.split("/")
                                        index = int(parts[2])
                                        
                                        if hasattr(self, "fragment_types_list") and index < len(self.fragment_types_list):
                                            frag_type = self.fragment_types_list[index]
                                            
                                            if frag_type == "THINK":
                                                if self.send_deepthink:
                                                    content += str(v)
                                            elif frag_type == "SEARCH":
                                                pass
                                            else:
                                                content += str(v)
                                    except (ValueError, IndexError):
                                        pass
                                        
                                # Check for status update: response/fragments/0/status
                                elif p.startswith("response/fragments/") and p.endswith("/status"):
                                    if v == "FINISHED":
                                        # The main closer is the start of RESPONSE or global finish.
                                        pass

                        if content or finish_reason:
                            openai_chunk = {
                                "id": "chatcmpl-custom",
                                "object": "chat.completion.chunk",
                                "created": int(time.time()),
                                "model": "deepseek-chat",
                                "choices": [
                                    {
                                        "index": 0,
                                        "delta": {"content": content} if content else {},
                                        "finish_reason": finish_reason
                                    }
                                ]
                            }
                            await queue.put(f"data: {json.dumps(openai_chunk)}\n\n")
                            
                    except json.JSONDecodeError:
                        pass
        except Exception as e:
            print(f"Error processing chunk: {e}")

    async def set_deepthink_state(self, state: bool):
        """
        Toggles the DeepThink mode to the desired state.
        """
        button = self.page.locator("button.ds-toggle-button", has_text="DeepThink")
        
        if await button.count() == 0:
            print("DeepThink button not found.")
            return

        class_attr = await button.first.get_attribute("class") or ""
        is_selected = "ds-toggle-button--selected" in class_attr
        
        if is_selected != state:
            print(f"Toggling DeepThink to {state}...")
            await button.first.click()
        else:
            print(f"DeepThink is already {state}.")

    async def set_search_state(self, state: bool):
        """
        Toggles the Search mode to the desired state.
        """
        button = self.page.locator("button.ds-toggle-button", has_text="Search")
        
        if await button.count() == 0:
            print("Search button not found.")
            return

        class_attr = await button.first.get_attribute("class") or ""
        is_selected = "ds-toggle-button--selected" in class_attr
        
        if is_selected != state:
            print(f"Toggling Search to {state}...")
            await button.first.click()
        else:
            print(f"Search is already {state}.")

    async def set_sidebar_status(self, open: bool):
        """
        Sets the sidebar status to open or closed.
        """
        sidebar_inner_selector = "div.b8812f16.a2f3d50e"
        sidebar_closed_class = "_70b689f"
        close_button_selector = "div.ds-icon-button._7d1f5e2"
        open_button_selector = "div.e5bf614e >> div.ds-icon-button._4f3769f >> nth=0"

        sidebar_inner = self.page.locator(sidebar_inner_selector)
        if await sidebar_inner.count() == 0:
            print("Sidebar inner container not found.")
            return

        class_attr = await sidebar_inner.first.get_attribute("class") or ""
        is_closed = sidebar_closed_class in class_attr
        is_open = not is_closed

        if open:
            if is_open:
                print("Sidebar is already open.")
                return

            print("Opening sidebar...")
            open_btn = self.page.locator(open_button_selector)
            if await open_btn.is_visible():
                await open_btn.click()
            else:
                print("Open sidebar button not visible.")
                
        else:
            if is_closed:
                print("Sidebar is already closed.")
                return
            
            print("Closing sidebar...")
            close_btn = self.page.locator(close_button_selector)
            if await close_btn.is_visible():
                await close_btn.click()
            else:
                print("Close sidebar button not visible.")

    async def click_new_chat(self, source: str = "auto"):
        """
        Clicks the New Chat button.
        """
        simple_new_chat_selector = "div.e5bf614e >> div.ds-icon-button._4f3769f >> nth=1"
        sidebar_new_chat_selector = "div._5a8ac7a.a084f19e"

        if source == "simple":
            print("Clicking New Chat (Simple)...")
            btn = self.page.locator(simple_new_chat_selector)
            if await btn.count() > 0:
                await btn.click()
            else:
                print("New Chat (Simple) button not found.")
                
        elif source == "sidebar":
            print("Clicking New Chat (Sidebar)...")
            btn = self.page.locator(sidebar_new_chat_selector)
            if await btn.count() > 0:
                await btn.click()
            else:
                print("New Chat (Sidebar) button not found.")
                
        elif source == "auto":
            print("Attempting to click New Chat (Auto)...")
            simple_btn = self.page.locator(simple_new_chat_selector)
            if await simple_btn.count() > 0:
                print("Found Simple New Chat button. Clicking...")
                await simple_btn.click()
                return
                
            sidebar_btn = self.page.locator(sidebar_new_chat_selector)
            if await sidebar_btn.count() > 0:
                print("Found Sidebar New Chat button. Clicking...")
                await sidebar_btn.click()
                return
                
            print("Could not find New Chat button in either mode.")
        else:
            print(f"Unknown source: {source}")

    async def enter_message(self, message: str):
        """
        Public wrapper for entering a message.
        """
        await self._enter_message(message)

    async def send_message(self):
        """
        Public wrapper for sending a message.
        """
        await self._send_message()

    async def _enter_message(self, message: str):
        """
        Enters the message into the chat input textarea.
        """
        # The textarea has placeholder "Message DeepSeek"
        textarea = self.page.locator("textarea[placeholder='Message DeepSeek']")
        if await textarea.count() == 0:
            print("Message textarea not found.")
            return
        print(f"Entering message: {message}")
        await textarea.fill(message)

    async def _send_message(self):
        """
        Clicks the send button if it is enabled.
        """
        # The send button is a div with role="button" and class "ds-icon-button"
        # The send button has a specific hashed class "_7436101"
        send_button = self.page.locator("div.ds-icon-button._7436101")
        
        if await send_button.count() > 0:
            is_disabled = await send_button.get_attribute("aria-disabled") == "true"
            if not is_disabled:
                print("Clicking send button...")
                await send_button.click()
            else:
                print("Send button is disabled. Cannot send message.")
        else:
            print("Send button could not be located.")

    async def _click_new_chat(self):
        """
        Clicks the New Chat button.
        """
        await self.click_new_chat(source="auto")
